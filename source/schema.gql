# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AddTicketInput {
  title: String!
  genre: [String!]!
  price: Float!
  inventory: Int!
  imageUrl: String!
  date: DateTime!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type Edge {
  cursor: String!
  node: Ticket!
}

type Movie {
  _id: ObjectId!
  title: String!
  year: Int
  rated: String
  released: DateTime
  runtime: Int
  genre: [String!]!
  director: String!
  writers: [String!]!
  actors: [String!]!
  plot: String!
  language: String!
  country: String!
  awards: [String!]
  posterUrl: String
  ratings: [Rating!]
  metascore: Int
  imdbRating: Float
  imdbVotes: Int
  imdbID: String!
  dvdReleased: DateTime
  boxOffice: Int
  production: String
  website: String
}

type Mutation {
  """Persists a new single Ticket"""
  addTicket(input: AddTicketInput!): Ticket!
}

"""Mongo object id scalar type"""
scalar ObjectId

type PageInfo {
  hasNextPage: Boolean!
}

type PaginatedResults {
  pageInfo: PageInfo!
  edges: [Edge!]!
}

type Query {
  """Fetches a single Ticket by its ID"""
  ticket(input: TicketInput!): Ticket

  """
  Fetches a list of Tickets with pagination.
  Pagination can be controlled by setting the 'after' parameter with the cursor.
  To navigate to the next page, set 'after' with the cursor of the latest node from the current query.
  """
  listTickets(
    """The amount of Tickets to be fetched"""
    first: Int

    """
    True if you wish to fetch only Tickets with Movie data, false otherwise
    """
    hasMovieData: Boolean

    """
    The cursor of the latest Ticket from the previous query. Sets this cursor as the starting point to execute the query.
    """
    after: String
  ): PaginatedResults!
}

type Rating {
  source: String!
  value: String!
}

type Subscription {
  """
  Initialize Tickets by fetching data from the Bonsai endpoint, and publishes
  Tickets batches as soon as they are persisted on the database.
  """
  initializeTickets: TicketSubscription!
}

type Ticket {
  _id: ObjectId!
  title: String!
  genre: [String!]!
  price: Float!
  inventory: Int!
  imageUrl: String!
  date: DateTime!
  movie: Movie
}

input TicketInput {
  id: ObjectId!
}

type TicketSubscription {
  tickets: [Ticket!]
}
